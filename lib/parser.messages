prog: SEMICOLON
##
## Ends in an error in state: 0.
##
## prog' -> . prog [ # ]
##
## The known suffix of the stack is as follows:
##
##

Expected a statement or expression, but found `;`.

prog: WHILE WHILE
##
## Ends in an error in state: 1.
##
## while_loop -> WHILE . LPAREN expr RPAREN block_statement [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## WHILE
##

Expected `(` after `while` keyword.

prog: WHILE LPAREN WHILE
##
## Ends in an error in state: 2.
##
## while_loop -> WHILE LPAREN . expr RPAREN block_statement [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## WHILE LPAREN
##

Expected expression after `(`.

prog: NOT WHILE
##
## Ends in an error in state: 6.
##
## expr_without_block -> NOT . expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## NOT
##

Expected expression after `not` operator.

prog: MINUS WHILE
##
## Ends in an error in state: 7.
##
## expr_without_block -> MINUS . expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## MINUS
##

Expected expression after unary `-` operator.

prog: LPAREN WHILE
##
## Ends in an error in state: 8.
##
## expr_without_block -> LPAREN . expr RPAREN [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

Expected expression after `(`.

prog: LPAREN LBRACE SEMICOLON
##
## Ends in an error in state: 9.
##
## block_expr -> LBRACE . block_expr_inside RBRACE [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL ELSE DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Expected expression or statement within block.

prog: LET WHILE
##
## Ends in an error in state: 10.
##
## statement -> LET . IDENTIFIER COLON IDENTIFIER ASSIGN expr SEMICOLON [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
## statement -> LET . IDENTIFIER COLON IDENTIFIER LBRACKET expr RBRACKET SEMICOLON [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
## statement -> LET . IDENTIFIER COLON IDENTIFIER SEMICOLON [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## LET
##

Expected identifier after `let`.

prog: LET IDENTIFIER WHILE
##
## Ends in an error in state: 11.
##
## statement -> LET IDENTIFIER . COLON IDENTIFIER ASSIGN expr SEMICOLON [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
## statement -> LET IDENTIFIER . COLON IDENTIFIER LBRACKET expr RBRACKET SEMICOLON [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
## statement -> LET IDENTIFIER . COLON IDENTIFIER SEMICOLON [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## LET IDENTIFIER
##

Expected `:` after identifier in let statement followed by a type.

prog: LET IDENTIFIER COLON WHILE
##
## Ends in an error in state: 12.
##
## statement -> LET IDENTIFIER COLON . IDENTIFIER ASSIGN expr SEMICOLON [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
## statement -> LET IDENTIFIER COLON . IDENTIFIER LBRACKET expr RBRACKET SEMICOLON [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
## statement -> LET IDENTIFIER COLON . IDENTIFIER SEMICOLON [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## LET IDENTIFIER COLON
##

Expected type after `:` in let statement.

prog: LET IDENTIFIER COLON IDENTIFIER WHILE
##
## Ends in an error in state: 13.
##
## statement -> LET IDENTIFIER COLON IDENTIFIER . ASSIGN expr SEMICOLON [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
## statement -> LET IDENTIFIER COLON IDENTIFIER . LBRACKET expr RBRACKET SEMICOLON [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
## statement -> LET IDENTIFIER COLON IDENTIFIER . SEMICOLON [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## LET IDENTIFIER COLON IDENTIFIER
##

Expected `[` or `;` after base type in let statement.

prog: LET IDENTIFIER COLON IDENTIFIER LBRACKET WHILE
##
## Ends in an error in state: 15.
##
## statement -> LET IDENTIFIER COLON IDENTIFIER LBRACKET . expr RBRACKET SEMICOLON [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## LET IDENTIFIER COLON IDENTIFIER LBRACKET
##

Expected expression for array size after `[`.

prog: LPAREN IF WHILE
##
## Ends in an error in state: 17.
##
## ifelse_expr -> IF . LPAREN expr RPAREN block_expr option(preceded(ELSE,block_expr)) [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## IF
##

Expected `(` after `if` keyword.

prog: LPAREN IF LPAREN WHILE
##
## Ends in an error in state: 18.
##
## ifelse_expr -> IF LPAREN . expr RPAREN block_expr option(preceded(ELSE,block_expr)) [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## IF LPAREN
##

Expected expression after `(`.

prog: IDENTIFIER WHILE
##
## Ends in an error in state: 19.
##
## expr_without_block -> IDENTIFIER . ASSIGN expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> IDENTIFIER . LBRACKET expr RBRACKET ASSIGN expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> IDENTIFIER . option(delimited(LBRACKET,expr,RBRACKET)) [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER
##

Unexpected token after identifier

prog: IDENTIFIER LBRACKET WHILE
##
## Ends in an error in state: 20.
##
## expr_without_block -> IDENTIFIER LBRACKET . expr RBRACKET ASSIGN expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## option(delimited(LBRACKET,expr,RBRACKET)) -> LBRACKET . expr RBRACKET [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER LBRACKET
##

Expected expression inside `[]`.

prog: IDENTIFIER LBRACKET FALSE WHILE
##
## Ends in an error in state: 26.
##
## bin_expr -> expr . PLUS expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . MINUS expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . MUL expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . DIV expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LSH expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . RSH expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . BAND expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . BOR expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . GT expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . GEQ expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LT expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LEQ expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . EQUAL expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LAND expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LOR expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## expr_without_block -> IDENTIFIER LBRACKET expr . RBRACKET ASSIGN expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## option(delimited(LBRACKET,expr,RBRACKET)) -> LBRACKET expr . RBRACKET [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER LBRACKET expr
##

Expected `]` to close the `[`.

prog: IDENTIFIER RSH WHILE
##
## Ends in an error in state: 27.
##
## bin_expr -> expr RSH . expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr RSH
##

Expected expression after `>>` operator.

prog: IDENTIFIER RSH FALSE WHILE
##
## Ends in an error in state: 28.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr RSH expr . [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr RSH expr
##

Unexpected token after expression.

prog: IDENTIFIER PLUS WHILE
##
## Ends in an error in state: 29.
##
## bin_expr -> expr PLUS . expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr PLUS
##

Expected expression after `+` operator.

prog: IDENTIFIER PLUS FALSE WHILE
##
## Ends in an error in state: 30.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr PLUS expr . [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr PLUS expr
##

Unexpected token after expression.

prog: IDENTIFIER MUL WHILE
##
## Ends in an error in state: 31.
##
## bin_expr -> expr MUL . expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr MUL
##

Expected expression after `*`.

prog: IDENTIFIER MUL FALSE WHILE
##
## Ends in an error in state: 32.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr MUL expr . [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr MUL expr
##

Unexpected keyword after expression.
Expecte


prog: IDENTIFIER LPAREN WHILE
##
## Ends in an error in state: 33.
##
## expr_without_block -> expr LPAREN . arg_list RPAREN [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr LPAREN
##

Expected comma separated argument list or `()`.


prog: IDENTIFIER LPAREN FALSE WHILE
##
## Ends in an error in state: 36.
##
## bin_expr -> expr . PLUS expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MINUS expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MUL expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . DIV expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LSH expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . RSH expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BAND expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BOR expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GT expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GEQ expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LT expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LEQ expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . EQUAL expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LAND expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LOR expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## separated_nonempty_list(COMMA,expr) -> expr . [ RPAREN ]
## separated_nonempty_list(COMMA,expr) -> expr . COMMA separated_nonempty_list(COMMA,expr) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## expr
##

Expected closing `)`.

prog: IDENTIFIER NOT_EQUAL WHILE
##
## Ends in an error in state: 37.
##
## bin_expr -> expr NOT_EQUAL . expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr NOT_EQUAL
##

Expected expression after `!=`.

prog: IDENTIFIER NOT_EQUAL FALSE WHILE
##
## Ends in an error in state: 38.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr NOT_EQUAL expr . [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr NOT_EQUAL expr
##

Unexpected token after expression.

prog: IDENTIFIER MINUS WHILE
##
## Ends in an error in state: 39.
##
## bin_expr -> expr MINUS . expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr MINUS
##

Expected expression after `-`.

prog: IDENTIFIER MINUS FALSE WHILE
##
## Ends in an error in state: 40.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr MINUS expr . [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr MINUS expr
##

Unexpected token after expression.

prog: IDENTIFIER DIV WHILE
##
## Ends in an error in state: 41.
##
## bin_expr -> expr DIV . expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr DIV
##

Expected expression after `/`.

prog: IDENTIFIER DIV FALSE WHILE
##
## Ends in an error in state: 42.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr DIV expr . [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr DIV expr
##

Unexpected keyword after expression.


prog: IDENTIFIER LT WHILE
##
## Ends in an error in state: 45.
##
## bin_expr -> expr LT . expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr LT
##

Expected expression after `<`.

prog: IDENTIFIER LT FALSE WHILE
##
## Ends in an error in state: 46.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr LT expr . [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr LT expr
##

Unexpected token after expression.

prog: IDENTIFIER LSH WHILE
##
## Ends in an error in state: 47.
##
## bin_expr -> expr LSH . expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr LSH
##

Expected expression after `<<`.

prog: IDENTIFIER LSH FALSE WHILE
##
## Ends in an error in state: 48.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr LSH expr . [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr LSH expr
##

Unexpected token after expression.

prog: IDENTIFIER LEQ WHILE
##
## Ends in an error in state: 49.
##
## bin_expr -> expr LEQ . expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr LEQ
##

Expected expression after `<=`.

prog: IDENTIFIER LEQ FALSE WHILE
##
## Ends in an error in state: 50.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr LEQ expr . [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr LEQ expr
##

Unexpected token after expression.

prog: IDENTIFIER GT WHILE
##
## Ends in an error in state: 51.
##
## bin_expr -> expr GT . expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr GT
##

Expected expression after `>`.

prog: IDENTIFIER GT FALSE WHILE
##
## Ends in an error in state: 52.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr GT expr . [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr GT expr
##

Unexpected token after expression.

prog: IDENTIFIER GEQ WHILE
##
## Ends in an error in state: 53.
##
## bin_expr -> expr GEQ . expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr GEQ
##

Expected expression after `>=`.

prog: IDENTIFIER GEQ FALSE WHILE
##
## Ends in an error in state: 54.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr GEQ expr . [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr GEQ expr
##

Unexpected token after expression.

prog: IDENTIFIER LOR WHILE
##
## Ends in an error in state: 55.
##
## bin_expr -> expr LOR . expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr LOR
##

Expected expression after `||`.

prog: IDENTIFIER LOR FALSE WHILE
##
## Ends in an error in state: 56.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr LOR expr . [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr LOR expr
##

Unexpected token after expression.

prog: IDENTIFIER LAND WHILE
##
## Ends in an error in state: 57.
##
## bin_expr -> expr LAND . expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr LAND
##

Expected expression after `&&`.

prog: IDENTIFIER LAND FALSE WHILE
##
## Ends in an error in state: 58.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr LAND expr . [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr LAND expr
##

Unexpected token after expression.

prog: IDENTIFIER EQUAL WHILE
##
## Ends in an error in state: 59.
##
## bin_expr -> expr EQUAL . expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr EQUAL
##

Expected expression after `==`.

prog: IDENTIFIER EQUAL FALSE WHILE
##
## Ends in an error in state: 60.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr EQUAL expr . [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr EQUAL expr
##

Unexpected token after expression.

prog: IDENTIFIER BOR WHILE
##
## Ends in an error in state: 61.
##
## bin_expr -> expr BOR . expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr BOR
##

Expected expression after `|`.

prog: IDENTIFIER BOR FALSE WHILE
##
## Ends in an error in state: 62.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr BOR expr . [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr BOR expr
##

Unexpected token after expression.

prog: IDENTIFIER BAND WHILE
##
## Ends in an error in state: 63.
##
## bin_expr -> expr BAND . expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr BAND
##

Expected expression after `&`.

prog: IDENTIFIER BAND FALSE WHILE
##
## Ends in an error in state: 64.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr BAND expr . [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr BAND expr
##

Unexpected token after expression.

prog: IDENTIFIER LPAREN IDENTIFIER COMMA WHILE
##
## Ends in an error in state: 65.
##
## separated_nonempty_list(COMMA,expr) -> expr COMMA . separated_nonempty_list(COMMA,expr) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##

Expected another expression in argument list.

prog: IDENTIFIER LBRACKET IDENTIFIER RBRACKET WHILE
##
## Ends in an error in state: 69.
##
## expr_without_block -> IDENTIFIER LBRACKET expr RBRACKET . ASSIGN expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## option(delimited(LBRACKET,expr,RBRACKET)) -> LBRACKET expr RBRACKET . [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER LBRACKET expr RBRACKET
##

Expected expression, `=` or `;` after `]`.

prog: IDENTIFIER LBRACKET IDENTIFIER RBRACKET ASSIGN WHILE
##
## Ends in an error in state: 70.
##
## expr_without_block -> IDENTIFIER LBRACKET expr RBRACKET ASSIGN . expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER LBRACKET expr RBRACKET ASSIGN
##

Expected expression on the right hand side of assignment.

prog: IDENTIFIER LBRACKET IDENTIFIER RBRACKET ASSIGN FALSE WHILE
##
## Ends in an error in state: 71.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> IDENTIFIER LBRACKET expr RBRACKET ASSIGN expr . [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER LBRACKET expr RBRACKET ASSIGN expr
##

Expected `;` or binary operator after assignment.

prog: IDENTIFIER ASSIGN WHILE
##
## Ends in an error in state: 72.
##
## expr_without_block -> IDENTIFIER ASSIGN . expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER ASSIGN
##

Expected expression on the right hand side of assignment.

prog: IDENTIFIER ASSIGN FALSE WHILE
##
## Ends in an error in state: 73.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> IDENTIFIER ASSIGN expr . [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER ASSIGN expr
##

Expected `;` or binary operator after assignment.

prog: LPAREN IF LPAREN FALSE WHILE
##
## Ends in an error in state: 75.
##
## bin_expr -> expr . PLUS expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . MINUS expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . MUL expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . DIV expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LSH expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . RSH expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . BAND expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . BOR expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . GT expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . GEQ expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LT expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LEQ expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . EQUAL expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LAND expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LOR expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## ifelse_expr -> IF LPAREN expr . RPAREN block_expr option(preceded(ELSE,block_expr)) [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## IF LPAREN expr
##

Expected closing `)` after if condition.

prog: LPAREN IF LPAREN IDENTIFIER RPAREN WHILE
##
## Ends in an error in state: 76.
##
## ifelse_expr -> IF LPAREN expr RPAREN . block_expr option(preceded(ELSE,block_expr)) [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## IF LPAREN expr RPAREN
##

Expected opening `{` after if condition.

prog: IF LPAREN IDENTIFIER RPAREN LBRACE IDENTIFIER RBRACE WHILE
##
## Ends in an error in state: 77.
##
## ifelse_expr -> IF LPAREN expr RPAREN block_expr . option(preceded(ELSE,block_expr)) [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## IF LPAREN expr RPAREN block_expr
##

Expected `else`, `;` or binary operator after if expression.

prog: IF LPAREN IDENTIFIER RPAREN LBRACE IDENTIFIER RBRACE ELSE WHILE
##
## Ends in an error in state: 78.
##
## option(preceded(ELSE,block_expr)) -> ELSE . block_expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## ELSE
##

Expected opening `{` after `else`.

prog: LET IDENTIFIER COLON IDENTIFIER LBRACKET FALSE WHILE
##
## Ends in an error in state: 81.
##
## bin_expr -> expr . PLUS expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . MINUS expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . MUL expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . DIV expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LSH expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . RSH expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . BAND expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . BOR expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . GT expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . GEQ expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LT expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LEQ expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . EQUAL expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LAND expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LOR expr [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ RSH RBRACKET PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## statement -> LET IDENTIFIER COLON IDENTIFIER LBRACKET expr . RBRACKET SEMICOLON [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## LET IDENTIFIER COLON IDENTIFIER LBRACKET expr
##

Expected `]` to close `[`.

prog: LET IDENTIFIER COLON IDENTIFIER LBRACKET IDENTIFIER RBRACKET WHILE
##
## Ends in an error in state: 82.
##
## statement -> LET IDENTIFIER COLON IDENTIFIER LBRACKET expr RBRACKET . SEMICOLON [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## LET IDENTIFIER COLON IDENTIFIER LBRACKET expr RBRACKET
##

Expected `;` after array variable declaration.

prog: LET IDENTIFIER COLON IDENTIFIER ASSIGN WHILE
##
## Ends in an error in state: 84.
##
## statement -> LET IDENTIFIER COLON IDENTIFIER ASSIGN . expr SEMICOLON [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## LET IDENTIFIER COLON IDENTIFIER ASSIGN
##

Expected expression after `=`.

prog: LET IDENTIFIER COLON IDENTIFIER ASSIGN FALSE WHILE
##
## Ends in an error in state: 85.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## statement -> LET IDENTIFIER COLON IDENTIFIER ASSIGN expr . SEMICOLON [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## LET IDENTIFIER COLON IDENTIFIER ASSIGN expr
##

Expected `;` after variable declaration.

prog: LBRACE SEMICOLON
##
## Ends in an error in state: 87.
##
## block_expr -> LBRACE . block_expr_inside RBRACE [ WHILE TRUE STRING SEMICOLON RSH RBRACE PLUS NULLPTR NOT_EQUAL NOT MUL MINUS LT LSH LPAREN LOR LET LEQ LBRACE LAND INT IF IDENTIFIER GT GEQ FUN FALSE EQUAL EOF ELSE DIV BOR BAND ]
## block_statement -> LBRACE . list(statement) RBRACE [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ELSE ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Expected statement or expression within block or empty block.

prog: IF WHILE
##
## Ends in an error in state: 88.
##
## ifelse_expr -> IF . LPAREN expr RPAREN block_expr option(preceded(ELSE,block_expr)) [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## ifelse_statement -> IF . LPAREN expr RPAREN block_statement option(preceded(ELSE,block_statement)) [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## IF
##

Expected `(` after `if` keyword for its condition.

prog: IF LPAREN WHILE
##
## Ends in an error in state: 89.
##
## ifelse_expr -> IF LPAREN . expr RPAREN block_expr option(preceded(ELSE,block_expr)) [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## ifelse_statement -> IF LPAREN . expr RPAREN block_statement option(preceded(ELSE,block_statement)) [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## IF LPAREN
##

Expected expression after `(`.

prog: IF LPAREN FALSE WHILE
##
## Ends in an error in state: 90.
##
## bin_expr -> expr . PLUS expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . MINUS expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . MUL expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . DIV expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LSH expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . RSH expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . BAND expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . BOR expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . GT expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . GEQ expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LT expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LEQ expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . EQUAL expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LAND expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LOR expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## ifelse_expr -> IF LPAREN expr . RPAREN block_expr option(preceded(ELSE,block_expr)) [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## ifelse_statement -> IF LPAREN expr . RPAREN block_statement option(preceded(ELSE,block_statement)) [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## IF LPAREN expr
##

Expected closing `)` after if condition.

prog: IF LPAREN IDENTIFIER RPAREN WHILE
##
## Ends in an error in state: 91.
##
## ifelse_expr -> IF LPAREN expr RPAREN . block_expr option(preceded(ELSE,block_expr)) [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## ifelse_statement -> IF LPAREN expr RPAREN . block_statement option(preceded(ELSE,block_statement)) [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## IF LPAREN expr RPAREN
##

Expected `{` after if condition.

prog: IF LPAREN IDENTIFIER RPAREN LBRACE RBRACE SEMICOLON
##
## Ends in an error in state: 92.
##
## ifelse_statement -> IF LPAREN expr RPAREN block_statement . option(preceded(ELSE,block_statement)) [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## IF LPAREN expr RPAREN block_statement
##

Unexpected `;`.

prog: IF LPAREN IDENTIFIER RPAREN LBRACE RBRACE ELSE WHILE
##
## Ends in an error in state: 93.
##
## option(preceded(ELSE,block_statement)) -> ELSE . block_statement [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## ELSE
##

Expected `{` after `else` keyword.

prog: WHILE LPAREN IDENTIFIER RPAREN LBRACE SEMICOLON
##
## Ends in an error in state: 94.
##
## block_statement -> LBRACE . list(statement) RBRACE [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Expected statement within block or empty block.

prog: FUN WHILE
##
## Ends in an error in state: 95.
##
## statement -> FUN . IDENTIFIER LPAREN loption(separated_nonempty_list(COMMA,param)) RPAREN option(preceded(ARROW,IDENTIFIER)) block [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## FUN
##

Expected function name after `fun` keyword.

prog: FUN IDENTIFIER WHILE
##
## Ends in an error in state: 96.
##
## statement -> FUN IDENTIFIER . LPAREN loption(separated_nonempty_list(COMMA,param)) RPAREN option(preceded(ARROW,IDENTIFIER)) block [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## FUN IDENTIFIER
##

Expected `(` after function name.

prog: FUN IDENTIFIER LPAREN WHILE
##
## Ends in an error in state: 97.
##
## statement -> FUN IDENTIFIER LPAREN . loption(separated_nonempty_list(COMMA,param)) RPAREN option(preceded(ARROW,IDENTIFIER)) block [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## FUN IDENTIFIER LPAREN
##

Expected parameter list after `(`.

prog: FUN IDENTIFIER LPAREN IDENTIFIER WHILE
##
## Ends in an error in state: 98.
##
## param -> IDENTIFIER . COLON IDENTIFIER [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER
##

Expected type identifier after parameter name (parameters should be specified by `name : type`).

prog: FUN IDENTIFIER LPAREN IDENTIFIER COLON WHILE
##
## Ends in an error in state: 99.
##
## param -> IDENTIFIER COLON . IDENTIFIER [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER COLON
##

Expected type identifier after parameter name (parameters should be specified by `name : type`).

prog: FUN IDENTIFIER LPAREN IDENTIFIER COLON IDENTIFIER WHILE
##
## Ends in an error in state: 102.
##
## separated_nonempty_list(COMMA,param) -> param . [ RPAREN ]
## separated_nonempty_list(COMMA,param) -> param . COMMA separated_nonempty_list(COMMA,param) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## param
##

Expected `)` to close parameter list.

prog: FUN IDENTIFIER LPAREN IDENTIFIER COLON IDENTIFIER COMMA WHILE
##
## Ends in an error in state: 103.
##
## separated_nonempty_list(COMMA,param) -> param COMMA . separated_nonempty_list(COMMA,param) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## param COMMA
##

Expected parameter definition.

prog: FUN IDENTIFIER LPAREN RPAREN WHILE
##
## Ends in an error in state: 106.
##
## statement -> FUN IDENTIFIER LPAREN loption(separated_nonempty_list(COMMA,param)) RPAREN . option(preceded(ARROW,IDENTIFIER)) block [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## FUN IDENTIFIER LPAREN loption(separated_nonempty_list(COMMA,param)) RPAREN
##

Expected `{` to start the function body.

prog: FUN IDENTIFIER LPAREN RPAREN ARROW WHILE
##
## Ends in an error in state: 107.
##
## option(preceded(ARROW,IDENTIFIER)) -> ARROW . IDENTIFIER [ LBRACE ]
##
## The known suffix of the stack is as follows:
## ARROW
##

Expected function return type after `->`.

prog: FUN IDENTIFIER LPAREN RPAREN ARROW IDENTIFIER WHILE
##
## Ends in an error in state: 109.
##
## statement -> FUN IDENTIFIER LPAREN loption(separated_nonempty_list(COMMA,param)) RPAREN option(preceded(ARROW,IDENTIFIER)) . block [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## FUN IDENTIFIER LPAREN loption(separated_nonempty_list(COMMA,param)) RPAREN option(preceded(ARROW,IDENTIFIER))
##

Expected block for function body after return type.

prog: FUN IDENTIFIER LPAREN RPAREN ASSIGN WHILE
##
## Ends in an error in state: 110.
##
## statement -> FUN IDENTIFIER LPAREN loption(separated_nonempty_list(COMMA,param)) RPAREN option(preceded(ARROW,IDENTIFIER)) ASSIGN . EXTERN LPAREN STRING RPAREN [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## FUN IDENTIFIER LPAREN loption(separated_nonempty_list(COMMA,param)) RPAREN option(preceded(ARROW,IDENTIFIER)) ASSIGN
##

Expected '@extern' keyword after '=' in external function declaration.


prog: FUN IDENTIFIER LPAREN RPAREN ASSIGN EXTERN WHILE
##
## Ends in an error in state: 111.
##
## statement -> FUN IDENTIFIER LPAREN loption(separated_nonempty_list(COMMA,param)) RPAREN option(preceded(ARROW,IDENTIFIER)) ASSIGN EXTERN . LPAREN STRING RPAREN [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## FUN IDENTIFIER LPAREN loption(separated_nonempty_list(COMMA,param)) RPAREN option(preceded(ARROW,IDENTIFIER)) ASSIGN EXTERN
##

Expected '(' after '@extern' keyword.


prog: FUN IDENTIFIER LPAREN RPAREN ASSIGN EXTERN LPAREN WHILE
##
## Ends in an error in state: 112.
##
## statement -> FUN IDENTIFIER LPAREN loption(separated_nonempty_list(COMMA,param)) RPAREN option(preceded(ARROW,IDENTIFIER)) ASSIGN EXTERN LPAREN . STRING RPAREN [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## FUN IDENTIFIER LPAREN loption(separated_nonempty_list(COMMA,param)) RPAREN option(preceded(ARROW,IDENTIFIER)) ASSIGN EXTERN LPAREN
##

Expected string literal with external library/function name in '@extern()' declaration.


prog: FUN IDENTIFIER LPAREN RPAREN ASSIGN EXTERN LPAREN STRING WHILE
##
## Ends in an error in state: 113.
##
## statement -> FUN IDENTIFIER LPAREN loption(separated_nonempty_list(COMMA,param)) RPAREN option(preceded(ARROW,IDENTIFIER)) ASSIGN EXTERN LPAREN STRING . RPAREN [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## FUN IDENTIFIER LPAREN loption(separated_nonempty_list(COMMA,param)) RPAREN option(preceded(ARROW,IDENTIFIER)) ASSIGN EXTERN LPAREN STRING
##

Expected ')' to close external function declaration after string literal.


prog: FUN IDENTIFIER LPAREN RPAREN ASSIGN EXTERN LPAREN STRING RPAREN WHILE
##
## Ends in an error in state: 114.
##
## statement -> FUN IDENTIFIER LPAREN loption(separated_nonempty_list(COMMA,param)) RPAREN option(preceded(ARROW,IDENTIFIER)) ASSIGN EXTERN LPAREN STRING RPAREN . SEMICOLON [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## FUN IDENTIFIER LPAREN loption(separated_nonempty_list(COMMA,param)) RPAREN option(preceded(ARROW,IDENTIFIER)) ASSIGN EXTERN LPAREN STRING RPAREN
##

Expected ';' after '@extern' declaration.


prog: FALSE WHILE
##
## Ends in an error in state: 118.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## expr_statement -> expr . SEMICOLON [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr
##

Expected `;` or binary operator after expression.

prog: LBRACE RBRACE SEMICOLON
##
## Ends in an error in state: 120.
##
## list(statement) -> statement . list(statement) [ RBRACE EOF ]
##
## The known suffix of the stack is as follows:
## statement
##

Unexpected ';'.


prog: WHILE LPAREN IDENTIFIER RPAREN LBRACE LBRACE RBRACE EOF
##
## Ends in an error in state: 121.
##
## block_statement -> LBRACE list(statement) . RBRACE [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ELSE ]
##
## The known suffix of the stack is as follows:
## LBRACE list(statement)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 114, spurious reduction of production list(statement) ->
## In state 115, spurious reduction of production list(statement) -> statement list(statement)
##

Unclosed `{` at the end of file.

prog: LBRACE LBRACE RBRACE SEMICOLON
##
## Ends in an error in state: 125.
##
## block_expr_inside -> statement . block_expr_inside_rest [ RBRACE ]
## list(statement) -> statement . list(statement) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## statement
##

Unexpected `;`.

prog: LBRACE LBRACE RBRACE LBRACE RBRACE SEMICOLON
##
## Ends in an error in state: 126.
##
## block_expr_inside_rest -> statement . block_expr_inside_rest [ RBRACE ]
## list(statement) -> statement . list(statement) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## statement
##

Unexpected `;`.

prog: LBRACE LBRACE RBRACE FALSE WHILE
##
## Ends in an error in state: 127.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## block_expr_inside_rest -> expr . [ RBRACE ]
## expr_statement -> expr . SEMICOLON [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr
##

Expected `;` or `}` after expression.

prog: LBRACE FALSE WHILE
##
## Ends in an error in state: 130.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## block_expr_inside -> expr . [ RBRACE ]
## expr_statement -> expr . SEMICOLON [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
##
## The known suffix of the stack is as follows:
## expr
##

Expected `;` or `}` after expression.

prog: LPAREN LBRACE LBRACE RBRACE SEMICOLON
##
## Ends in an error in state: 133.
##
## block_expr_inside -> statement . block_expr_inside_rest [ RBRACE ]
##
## The known suffix of the stack is as follows:
## statement
##

Unexpected `;`.

prog: LPAREN LBRACE LBRACE RBRACE LBRACE RBRACE SEMICOLON
##
## Ends in an error in state: 134.
##
## block_expr_inside_rest -> statement . block_expr_inside_rest [ RBRACE ]
##
## The known suffix of the stack is as follows:
## statement
##

Unexpected `;`.

prog: LPAREN FALSE WHILE
##
## Ends in an error in state: 135.
##
## bin_expr -> expr . PLUS expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . MINUS expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . MUL expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . DIV expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LSH expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . RSH expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . BAND expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . BOR expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . GT expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . GEQ expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LT expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LEQ expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . EQUAL expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LAND expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LOR expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## expr_without_block -> LPAREN expr . RPAREN [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## LPAREN expr
##

Expected closing `)` after expression.

prog: MINUS FALSE WHILE
##
## Ends in an error in state: 137.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> MINUS expr . [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## MINUS expr
##

Unexpected keyword after expression.


prog: NOT FALSE WHILE
##
## Ends in an error in state: 138.
##
## bin_expr -> expr . PLUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MINUS expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . MUL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . DIV expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . RSH expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . BOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . GEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LT expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LEQ expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LAND expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## bin_expr -> expr . LOR expr [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> NOT expr . [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ SEMICOLON RSH RPAREN RBRACKET RBRACE PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV COMMA BOR BAND ]
##
## The known suffix of the stack is as follows:
## NOT expr
##

Unexpected keyword after expression.


prog: WHILE LPAREN FALSE WHILE
##
## Ends in an error in state: 139.
##
## bin_expr -> expr . PLUS expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . MINUS expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . MUL expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . DIV expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LSH expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . RSH expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . BAND expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . BOR expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . GT expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . GEQ expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LT expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LEQ expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . EQUAL expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . NOT_EQUAL expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LAND expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## bin_expr -> expr . LOR expr [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## expr_without_block -> expr . LPAREN arg_list RPAREN [ RSH RPAREN PLUS NOT_EQUAL MUL MINUS LT LSH LPAREN LOR LEQ LAND GT GEQ EQUAL DIV BOR BAND ]
## while_loop -> WHILE LPAREN expr . RPAREN block_statement [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## WHILE LPAREN expr
##

Expected closing `)` after condition.

prog: WHILE LPAREN IDENTIFIER RPAREN WHILE
##
## Ends in an error in state: 140.
##
## while_loop -> WHILE LPAREN expr RPAREN . block_statement [ WHILE TRUE STRING RBRACE NULLPTR NOT MINUS LPAREN LET LBRACE INT IF IDENTIFIER FUN FALSE EOF ]
##
## The known suffix of the stack is as follows:
## WHILE LPAREN expr RPAREN
##

Expected `{` atfer while condition.

prog: LBRACE RBRACE RBRACE
##
## Ends in an error in state: 143.
##
## prog -> list(statement) . EOF [ # ]
##
## The known suffix of the stack is as follows:
## list(statement)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 114, spurious reduction of production list(statement) ->
## In state 115, spurious reduction of production list(statement) -> statement list(statement)
##

Expected end of file.





